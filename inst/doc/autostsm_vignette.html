<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />



<title>Automatic Structural Time Series Model</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>
<style type="text/css">
a.anchor-section {margin-left: 10px; visibility: hidden; color: inherit;}
a.anchor-section::before {content: '#';}
.hasAnchor:hover a.anchor-section {visibility: visible;}
</style>
<script>// Anchor sections v1.0 written by Atsushi Yasumoto on Oct 3rd, 2020.
document.addEventListener('DOMContentLoaded', function() {
  // Do nothing if AnchorJS is used
  if (typeof window.anchors === 'object' && anchors.hasOwnProperty('hasAnchorJSLink')) {
    return;
  }

  const h = document.querySelectorAll('h1, h2, h3, h4, h5, h6');

  // Do nothing if sections are already anchored
  if (Array.from(h).some(x => x.classList.contains('hasAnchor'))) {
    return null;
  }

  // Use section id when pandoc runs with --section-divs
  const section_id = function(x) {
    return ((x.classList.contains('section') || (x.tagName === 'SECTION'))
            ? x.id : '');
  };

  // Add anchors
  h.forEach(function(x) {
    const id = x.id || section_id(x.parentElement);
    if (id === '') {
      return null;
    }
    let anchor = document.createElement('a');
    anchor.href = '#' + id;
    anchor.classList = ['anchor-section'];
    x.classList.add('hasAnchor');
    x.appendChild(anchor);
  });
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Automatic Structural Time Series Model</h1>



<p><code>autostm</code> (Automatic Structural Time Series Model) is designed to automatically detect the appropriate decomposition for a univariate time series into trend, seasonal, and cycle components using a state space approach. The unobserved components are estimated with the Kalman filter and all model parameters are estimated using maximum likelihood. The Kalman filter and smoother are implemented in Rcpp so it is reasonably fast. This package is designed to handle time series multiple seasonalities, seasonalities with fractional periodicities, missing data imputation, and irregularly spaced dates (i.e. daily data with missing data due to weekends and holidays, etc.).</p>
<p>With ease-of-use in mind, all the user has to do is provide a two column data frame: one column with dates and one column with the univariate time series. Everything else is handled by the algorithm including data frequency detection, trend specification, cycle specification, seasonal specification, missing data imputation, anomaly detection, structural break detection, and whether or not to log transform the data. The user can manually set the preferred decomposition if desired, however. All components are assumed to be stochastic, which allows for time-varying trend, cycle, and seasonalities, unless the user specifies otherwise. The algorithm can currently handle daily, monthly, and quarterly frequency as well as daily data that is weekday only. The user only needs to call <code>stsm_estimate</code> to fit the model and <code>stsm_forecast</code> to filter and forecast the data. Additionally, the user can call <code>stsm_detect_anomalies</code> and <code>stsm_detect_breaks</code> to perform anomaly and structural break detection respectively.</p>
<div id="state-space-model" class="section level1">
<h1>State Space Model</h1>
<p>The model is based on the decomposition</p>
<p><span class="math display">\[
Y_t = T_t + C_t + S_t + B X_t + e_t
\]</span></p>
<p>where <span class="math inline">\(Y_t\)</span> is a univariate time series, <span class="math inline">\(T_t\)</span> is the trend component, <span class="math inline">\(C_t\)</span> is the cycle component, <span class="math inline">\(S_t\)</span> is the seasonal component, <span class="math inline">\(X_t\)</span> is optional exogenous data, and <span class="math inline">\(e_t \sim N(0, \sigma_e^2)\)</span> is the observation error. The seasonal and cycle components are assumed to be of a trigonometric form, while the trend is assumed to be one of three types: a random walk, a random walk with an AR(1) drift, or a double random walk (random walk with a random walk drift).</p>
<p>For state space model is written as <span class="math display">\[
Y_t = A + H \beta + BX + e_t, e_t ~ N(0, R)\\
\beta_t = D + F \beta_{t-1} + u_t, u_t ~ N(0, Q)
\]</span></p>
<p>where the first equation is the observation equation and the second equation is the transition equation. <span class="math inline">\(H\)</span> is the observation matrix and <span class="math inline">\(R\)</span> is the observation error-covariance matrix. <span class="math inline">\(\beta_t\)</span> is the vector of the unobserved components (trend, seasonal, and cycle), <span class="math inline">\(F\)</span> is the transition matrix, and <span class="math inline">\(Q\)</span> is the transition error-covariance matrix.</p>
<div id="trend-models" class="section level2">
<h2>Trend Models</h2>
<p>If trend is “random-walk” the trend model is specified as the I(1) process <span class="math display">\[
T_t = T_{t-1} + e_t, e_t \sim N(0, \sigma_t^2)
\]</span></p>
<p>If trend is “random-walk-drift”, the trend model is specified as the I(1) process <span class="math display">\[
T_t = M_{t-1} + T_{t-1} + e_t, e_t \sim N(0, \sigma_t^2) \\
M_t = \delta + \phi_1 M_{t-1} + n_t, n_t \sim N(0, \sigma_m^2)
\]</span> where <span class="math inline">\(M_t\)</span> is the drift.</p>
<p>If trend is “double-random-walk”, the trend model is specified as the I(2) process <span class="math display">\[
T_t = M_{t-1} + T_{t-1} + e_t, e_t \sim N(0, \sigma_t^2) \\
M_t = M_{t-1} + n_t, n_t \sim N(0, \sigma_m^2)
\]</span></p>
</div>
<div id="cycle-model" class="section level2">
<h2>Cycle Model</h2>
<p>The cycle is modeled using either the trigonometric process</p>
<p><span class="math display">\[
\begin{bmatrix}
c_t \\
c_t^{*}
\end{bmatrix} = 
\rho \begin{bmatrix}
cos(\lambda) &amp; sin(\lambda) \\
-sin(\lambda) &amp; cos(\lambda)
\end{bmatrix}
\begin{bmatrix}
c_{t-1} \\
c_{t-1}^{*}
\end{bmatrix} + 
\begin{bmatrix}
u_t \\
u_t^{*}
\end{bmatrix}, u_t, u_t^{*} \sim N(0, \sigma_c^2)
\]</span> where <span class="math inline">\(\lambda\)</span> is the frequency of the cycle and <span class="math inline">\(\rho \in{(0,1)}\)</span> to make the cycle stationary for forecasting purposes, or the ARMA(2,1) process</p>
<p><span class="math display">\[
\begin{bmatrix}
c_t \\
c_{t-1} \\
e_t
\end{bmatrix} = 
\begin{bmatrix}
\psi_1 &amp; \psi_2 &amp; \theta_1 \\
1 &amp; 0 &amp; 0 \\
0 &amp; 0 &amp; 0
\end{bmatrix}
\begin{bmatrix}
c_{t-1} \\
c_{t-2} \\
e_{t-1}
\end{bmatrix} + 
\begin{bmatrix}
e_t \\
0 \\
e_t
\end{bmatrix}, 
e_t \sim N(0, \sigma_c^2)
\]</span> Th ARMA(2,1) specification can have real or complex roots, while the trigonometric specification will only have complex roots. The trigonometric specification is a special case of the ARMA(2,1) specification if it exists but was not detected by wavelet analysis.</p>
<p>If the roots are complex, the dynamics will be damped oscillations about the trend, which may not always be desirable. If the user would like to remove oscillations from the forecast that are caused by the complex roots, the user can specify, <code>dampen_cycle = TRUE</code> in <code>stsm_forecast</code>. This option will smooth the forecast of the cycle into the trend using a fitted sigmoid curve.</p>
</div>
<div id="seasonal-model" class="section level2">
<h2>Seasonal Model</h2>
<p>Seasonality is modeled using a Fourier series, which is the sum of sin-cos waves with each wave representing a seasonal pattern. Total seasonality is <span class="math display">\[
s_t = \sum_{j = 1}^{h} s_t^j
\]</span></p>
<p>where each season <span class="math inline">\(s_t^j\)</span> is modeled using the trigonometric specification below</p>
<p><span class="math display">\[
\begin{bmatrix}
s_t^j \\
s_t^{j,*}
\end{bmatrix} = 
\begin{bmatrix}
cos(\lambda_j) &amp; sin(\lambda_j) \\
-sin(\lambda_j) &amp; cos(\lambda_j)
\end{bmatrix}
\begin{bmatrix}
s_{t-1}^j \\
s_{t-1}^{j,*}
\end{bmatrix} + 
\begin{bmatrix}
w_t^j \\
w_t^{j,*}
\end{bmatrix}, w_t^j \sim N(0, \sigma_j^2)
\]</span> where <span class="math inline">\(s_t^{j,*}\)</span> exists by construction and is just an auxiliary variable, <span class="math inline">\(\lambda_j = \frac{2\pi j}{f}\)</span> is the frequency of season <span class="math inline">\(j\)</span>, <span class="math inline">\(j\)</span> represents the number of periods per year (i.e. <span class="math inline">\(j = 52\)</span> represents weekly seasonality at 52 periods per year), and <span class="math inline">\(f\)</span> is the frequency of the data (i.e. the number of observations per year). The seasons to include in the model are automatically detected in the algorithm using wavelet analysis. Each <span class="math inline">\(\lambda_j\)</span> is predetermined from wavelet analysis and are not estimated parameters.</p>
</div>
<div id="model-specification" class="section level2">
<h2>Model Specification</h2>
<p>The automatic model specification algorithm follows the procedure below. Rather than using brute force selection by checking every possible model combination and selecting the model that minimizes a selection criteria like AIC, which can be computationally intensive and time consuming, the procedure uses a series a statistical tests to determine model specification. However, the user is free to write their own brute force model selection routine from the functions provided in this package.</p>
<div id="frequency-detection" class="section level3">
<h3>Frequency Detection</h3>
<p>The first step is to detect the frequency of the data by examining the sequence of dates provided. If the difference in subsequent dates is closest to</p>
<ul>
<li>1, then a frequency of 365.25 is used for daily data</li>
<li>7, then a frequency of 52.17857 is used for weekly data</li>
<li>30, then a frequency of 12 is used for monthly data</li>
<li>90, then a frequency of 4 is used for quarterly data</li>
<li>365, then a frequency of 1 used for yearly data</li>
</ul>
<p>Once the frequency is detected, a sequence of continuous dates is constructed to ensure evenly spaced data. If an observation is missing for any of the dates in the constructed sequence, it is treated as a missing value. However, if the dates provided contain only weekdays and the data is of daily frequency, the frequency is changed to 260.8929 to reflect the number of weekdays per year.</p>
</div>
<div id="trend-detection" class="section level3">
<h3>Trend Detection</h3>
<p>The second step is to determine the specification of the trend. This mainly boils down to determining if the data is I(0), I(1), or I(2). To do determine the number of differences to make the data stationary, the ADF, PP, and KPSS tests are performed using the <code>forecast</code> package’s <code>ndiffs</code> function on the seasonal adjusted time series, where the seasonal adjustment is performed by decomposing the time series into a loess trend and seasonal component using the <code>stl</code> function. The trend is further split into a smoother trend and the cycle by fitting a loess trend to the <code>stl</code> trend using the <code>loess</code> function. <code>stl</code> requires that there are no missing values in the data, so any missing values are computed with the <code>na_kalman</code> function from the <code>imputeTS</code> package. If your know the missing data pattern in your data (i.e missing data should be 0), it’s best to fill in the missing data using your knowledge before allowing this method to fill in the rest.</p>
<p>The number of differences selected for the trend specification is the most agreed upon number of differences from the unit root tests. Next, the Cox-Stuart trend test from the <code>tsutils</code> package is preformed on the seasonally adjusted data to determine if the data is trending. However, since this test is sensitive to outliers, outliers in the seasonally adjusted series are detected and replaced using the <code>forecast</code>’s package <code>tsoutliers</code> function before the test is performed.</p>
<p>If the data is determined to be</p>
<ul>
<li>I(2), then the “double-random-walk” specification is used</li>
<li>I(1) with a trend, then the “random-walk-drift” specification is used</li>
<li>I(1) without a trend, then the “random-walk” specification is used</li>
<li>I(0) and no trend, then the “random-walk” trend specification with a deterministic trend is used to model a constant mean with an autoregressive component</li>
</ul>
</div>
<div id="multiplicative-vs-additive-detection" class="section level3">
<h3>Multiplicative vs Additive Detection</h3>
<p>The next step is to determine if the model should be based on a multiplicative of additive model. For a multiplicative model, the data must all be positive and satisfy one of two tests. Before the tests are performed, the data is seasonally adjusted using the procedure above.</p>
<p>The model is restricted to multiplicative of additive decomposition, rather than allowing the full range of Box-Cox transformations, so that the decomposition is easy to compare to the original time series. Additive makes the decomposition comparative in levels, multiplicative makes the decomposition comparative in percentages relative to the original time series, but Box-Cox transformations don’t have an easy interpretation like this. However, the user can Box-Cox transform the data prior to estimation and specify <code>multilicative = FALSE</code> if that method is preferred.</p>
<div id="trend-test" class="section level4">
<h4>Trend Test</h4>
<p>The first test is a test of a linear vs exponential trend. This test compares the log likelihood of 1) a linear regression of the seasonally adjusted data vs a linear trend, and 2) a linear regression of the logged seasonally adjusted data vs a linear trend using the <code>petest</code> from the <code>lmtest</code> package. A log trend model is selected if and only if the linear model is rejected and the log model is not rejected.</p>
</div>
<div id="seasonal-cycle-amplitude-test" class="section level4">
<h4>Seasonal-Cycle Amplitude Test</h4>
<p>The second test is a test for constant seasonal-cycle amplitude using the Cox-Stuart dispersion test from the <code>tsutils</code> package (using the <code>coxstuart</code> function) on the detrended data. Detrending is done using the trend from a loess-based seasonal decomposition using the <code>stl</code> function. Then, if the seasonal component is determined to have changing amplitude, a multiplicative model is used.</p>
</div>
</div>
<div id="seasonality-detection" class="section level3">
<h3>Seasonality Detection</h3>
<p>Next is Wavelet analysis for seasonal detection and frequency selection is performed by regressing a series of sin-cos waves on the detrended and cycle adjusted data. Detrending is done as above, and the detrended data may also be rescaled by the trend if the Cox-Stuart dispersion tests suggests that the detrended data does not have a constant amplitude. The regression is performed sequentially using the equation</p>
<p><span class="math display">\[
\tilde{y_t} = \sum_{i = 1}^j (a_j sin(j) + b_j cos(j))
\]</span></p>
<p>Selection is performed using forward stepwise regression for seasonal frequencies that include weekly and yearly seasonality only (where applicable) to make the model as parimonious as possible. If the user wants to allow detection of a fuller spectrum of seasonal frequencies, the user can set <code>full_seasonal_spectrum = TRUE</code> or set <code>seasonal_spectrum</code> to the vector of seasonal lengths to be tested. After each iteration, a <span class="math inline">\(\chi^2\)</span> test is performed for the sum of each pair of coefficients, <span class="math inline">\(\chi_j^2 = a_j^2 + b_j^2\)</span>, which corresponds to the squared power of each harmonic. Any harmonic that is not statistically significant is discarded before the next iteration so that only statistically significant harmonics are kept at each iteration. After all iterations, the remaining harmonics are selected as the seasonal frequencies that describe the seasonal pattern in the data. The statistical significance level used is fixed at 0.0001 (or 0.01%). This level is set to prevent spurious seasonal frequencies from being included in the model.</p>
</div>
<div id="cycle-detection" class="section level3">
<h3>Cycle Detection</h3>
<p>Finally, wavelet analysis for cycle detection and frequency selection is performed by regressing a series of sin-cos waves on the seasonally adjusted and detrended data. Detrending and seasonal adjustment is done as above. This new series may also be rescaled by the trend and seasonal factors if the Cox-Stuart dispersion tests suggests that the detrended data does not have a constant amplitude. If rescaling occurs, the seasonal component is converted into a multiplicative factor first. The regression is performed individually using the equation</p>
<p><span class="math display">\[
\tilde{y_t} = a_j sin(j) + b_j cos(j)
\]</span></p>
<p>for harmonics <span class="math inline">\(j\)</span> from 0.01 to 0.99 for every 0.01. After each iteration, a <span class="math inline">\(\chi^2\)</span> test is performed for <span class="math inline">\(\chi^2_j = a_j^2 + b_j^2\)</span>, which corresponds to the squared power of each harmonic. After all harmonics have been tested, the algorithm looks for local maxima from the power spectrum. The final selection for the cycle frequency corresponds to the harmonic that is a local maxima with the largest statistically significant power. The statistical significance level used is fixed at 0.0001 (or 0.01%). This level is set to prevent spurious cycles from being included in the model.</p>
<p>The cycle is set to the trigonometric form is a cycle is detected using wavelet analysis. Otherwise is set to the ARMA specification.</p>
</div>
</div>
<div id="the-kalman-filter" class="section level2">
<h2>The Kalman Filter</h2>
<p>To estimate the unobserved components (<span class="math inline">\(T_t, C_t, S_t\)</span>, and <span class="math inline">\(M_t\)</span>), the Kalman filter is utilized. The Kalman filter is a forward two-stage procedure that is the optimal linear filter based on the multivariate normal distribution. The “forwardness” of the filter means that it uses only data up to time <span class="math inline">\(t\)</span> to make an inference on the unobserved components at time <span class="math inline">\(t\)</span> and does peak into the future to make that inference.</p>
<div id="prediction-stage" class="section level3">
<h3>Prediction Stage</h3>
<p>The first stage is the prediction stage, which makes predictions on the unobserved components based on information up to time <span class="math inline">\(t-1\)</span>. This stage is made up of four equations, the first is the prediction of the unobserved components based on its time series properties</p>
<p><span class="math display">\[
B_{t|t-1} = \bar{D} + F \beta_{t-1|t-1}
\]</span></p>
<p>Second, is the prediction of the covariance matrix of the unobserved components</p>
<p><span class="math display">\[
P_{t|t-1} = F P_{t_1|t-1} F^{\prime} + Q
\]</span> Third, is the prediction error of the time series of interest <span class="math display">\[
\eta_{t|t-1} + Y_t - (A + H \beta_{t|t-1} + BX)
\]</span></p>
<p>And finally, we have the variance of the prediction error</p>
<p><span class="math display">\[
f_{t|t-1} = H P_{t|t-1} H^{\prime} + R
\]</span></p>
</div>
<div id="updating-stage" class="section level3">
<h3>Updating Stage</h3>
<p>The second stage is the updating stage, which makes predictions based on all information up to time <span class="math inline">\(t\)</span>. It consists of three equations. The first equation is the prediction of the unobserved components based on the the full information set</p>
<p><span class="math display">\[
\beta_{t|t} = B_{t|t-1} + K_t \eta_{t}
\]</span> where <span class="math inline">\(K_t\)</span> is the Kalman gain, which determines the optimal weight to give new information in making predictions about <span class="math inline">\(\beta_t\)</span> and is the second equation</p>
<p><span class="math display">\[
K_t = P_{t|t-1} H^{\prime} f_{t|t-1}^{-1}
\]</span> The last equation is the updating of the covariance matrix of the unobserved components</p>
<p><span class="math display">\[
P_{t|t} = P_{t|t-1} + K_t H^{\prime} P_{t|t-1}
\]</span> The seven equations above, make up the full Kalman filter routine. If <span class="math inline">\(Y_t\)</span> is missing for any observation, then</p>
<p><span class="math display">\[
B_{t|t} = B_{t|t-1} \\
P_{t|t} = P_{t|t-1} \\
K_t = 0 \\
f_{t|t-1} = \infty
\]</span></p>
</div>
<div id="kalman-smoothing" class="section level3">
<h3>Kalman Smoothing</h3>
<p>Once the Kalman filter is applied to the data, a smoothing procedure can applied in the backward direction to make a better inference of the unobserved components based on the entire data set. Unlike the filter, the smoother does peak into the future to make an inference on the unobserved components at time <span class="math inline">\(t\)</span>. This procedure consists of only two equations.</p>
<p>The first equation updates the prediction of the unobserved components based on all the available information</p>
<p><span class="math display">\[
\beta_{t|T} = \beta_{t|t} + P_{t|t} F^{\prime} P_{t|t}^{-1} (\beta_{t+1|T} - \beta_{t+1|t})
\]</span> The second equation updates the covariance matrix of the unobserved components based on all the available information</p>
<p><span class="math display">\[
P_{t|T} = P_{t|t} + P_{t|t} F^{\prime} P_{t+1|t}^{-1} (P_{t+1|T} - P_{t+1|t}) P_{t+1|t}^{-1 \prime} F P_{t|t}^{\prime}
\]</span></p>
</div>
</div>
<div id="maximum-likelihood-estimation" class="section level2">
<h2>Maximum Likelihood Estimation</h2>
<p>The model above is estimated using MLE with box constraints. The log likelihood is given by</p>
<p><span class="math display">\[
ln(L(\theta)) = -\frac{1}{2} \sum_{t=1}^T \ln(|f_{t|t-1}|) - \frac{1}{2}\sum_{t=1}^T \eta_{t|t-1}^{\prime} f_{t|t-1}^{-1} \eta_{t|t-1} 
\]</span> for all values that are not missing.</p>
</div>
<div id="initial-parameter-values" class="section level2">
<h2>Initial Parameter Values</h2>
<div id="model-prior" class="section level3">
<h3>Model Prior</h3>
<p>Initial parameter values are essential for finding a good model when using maximum likelihood estimation. To this end, the algorithm uses initial parameter values derived from a decomposition using the <code>stl</code> function, which acts like the model prior and is represented by</p>
<p><span class="math display">\[
Y_t^* = T_t^* + C_t^* + S_t^* + e_t^*
\]</span></p>
<p>This function will decompose the time series into trend and seasonality. The seasonality is then further split into the seasonal harmonics by fitted a linear regression on the seasonal Fourier series and extracting the fitted components. Finally, the trend is further split into a smoother trend and the cycle by fitting a loess trend to the <code>stl</code> trend using the <code>loess</code> function. The drift is then derived by taking the first difference of the trend.</p>
</div>
<div id="trend-and-drift-initial-values" class="section level3">
<h3>Trend and Drift Initial Values</h3>
<p>Theese parameters are set initiall to match to the theoretical variance of the model depending on the trend type. If the trend is set to “random-walk” then <span class="math inline">\(\sigma_t = sd(\Delta T_t^{*})\)</span>. If the trend is set to “double-random-walk” then <span class="math inline">\(\sigma_t = \sigma_m = sd(\Delta T_t^{*})/sqrt(2)\)</span>. If the trend is set to “random-walk-drift”, an AR(1) model is fit the drift prior, <span class="math inline">\(\sigma_m\)</span> is set to the standard deviation of the model errors, <span class="math inline">\(\phi_1\)</span> is the set to the estimated AR(1) parameter, and <span class="math inline">\(\sigma_t\)</span> is set to <span class="math inline">\(\sqrt{var(\Delta T_t^*) - \frac{\sigma_m^2}{1 - \phi_1^2}}\)</span> the theoretical variance if the trend is I(1).</p>
</div>
<div id="cycle-initial-values" class="section level3">
<h3>Cycle Initial Values</h3>
<p>If the cycle model is set to the ARMA specification or a cycle is not detected, an ARMA(2, 0, 1) process is fit to the cycle prior (with noise added by setting the cycle equal to the seasonal adjusted value minus the trend) to set the parameters for the cycle component. The estimated AR and MA components are then used as the initial parameters. IF the cycle is model is set to the trigonometric specification, <span class="math inline">\(\lambda\)</span> is set to be <span class="math inline">\(\frac{2\pi}{c}\)</span> where <span class="math inline">\(c\)</span> is the estimated cycle period. <span class="math inline">\(\rho\)</span> is set to the maximum eigenvalue of an ARMA(2,0,1) process fit to the cycle prior as this is related to the speed of convergence towards the trend as <span class="math inline">\(\rho\)</span> is in a AR(1) process. Finally, <span class="math inline">\(\sigma_c\)</span> is set to the standard deviation of the model errors.</p>
</div>
<div id="seasonality-initial-values" class="section level3">
<h3>Seasonality Initial Values</h3>
<p>If seasonality is included, each <span class="math inline">\(\sigma_j\)</span> is set to <span class="math inline">\(sd(\Delta S_t^*)/sqrt(h)\)</span> where h is the number of seasonal harmonics so <span class="math inline">\(var(\Delta S_t^*) = \sum_j \sigma_j^2\)</span></p>
</div>
<div id="remainder" class="section level3">
<h3>Remainder</h3>
<p>Lastly, <span class="math inline">\(\sigma_e\)</span> is set the the standard deviation of the remainder of the model prior, <span class="math inline">\(sd(e_t^*)\)</span> plus any non-zero covariances between the prior components.</p>
</div>
<div id="unobserved-component-initial-values" class="section level3">
<h3>Unobserved Component Initial Values</h3>
<p>The initial values of the unobserved components must also be initialized. These values are not optimized but set in advance to aid in speed. The only value set to optimize is one value for the diagonal of the covariance matrix <span class="math inline">\(P_{0|0}\)</span>, which is set to the identity matrix.</p>
</div>
<div id="box-constraints" class="section level3">
<h3>Box Constraints</h3>
<p>The box constraints act like priors and provide bounds on parameter estimates to ensure a reasonable model. The constraints include startionarity constraints for the cycle, <span class="math inline">\(0 &lt; \rho &lt; 1\)</span> and drift, <span class="math inline">\(-1 &lt; \phi &lt; 1\)</span>, as well as <span class="math inline">\(\sigma_x &gt; 0\)</span> for all variance parameters. Trend smoothness constraints</p>
<p><span class="math display">\[
\sigma_t + \sigma_m &lt; \sigma_e \\
\sigma_t + \sigma_m &lt; \sigma_c \\
\sigma_t + \sigma_m &lt; \sum_j \sigma_j
\]</span></p>
<p>are also included to ensure that the trend accounts for the least variability among all the components. It can be relaxed by setting <code>unconstrained = TRUE</code> in <code>stsm_estimate</code>.</p>
</div>
</div>
<div id="anomaly-detection" class="section level2">
<h2>Anomaly Detection</h2>
<p>Anomaly detection uses the estimated structural model and the recursive nature of the Kalman filter to detect observations that are outside a given threshold of the model’s predicted values for time <span class="math inline">\(t\)</span> given estimates at time <span class="math inline">\(t-1\)</span>. The threshold is determined by the forecast error variance of the estimated structural model. Anomalies that are detected can then be replaced with the modeled predicted values if the user wants to replace outliers.</p>
<p><code>stsm_detect_anomalies</code> will only plot if anomalies are detected and <code>plot = TRUE</code>.</p>
<p>The model makes recursive predictions for the j-th step ahead using</p>
<p><span class="math display">\[
\hat{Y_{t+j}} = H F^j \beta_{t}
\]</span> where the j-step ahead forecast error variance is given by</p>
<p><span class="math display">\[
FEV = \left(\sum_{i=0}^{j-1} H F^i Q F^{i\prime} H^{\prime}\right) + R 
\]</span></p>
</div>
<div id="structural-break-detection" class="section level2">
<h2>Structural Break Detection</h2>
<p>Structural breaks are detected using the <code>breakpoints</code> function from the <code>strucchange</code> package. It attempts to detect structural breaks in the trend, cycle, and seasonalities based on the estimated structural model.</p>
<p>If the data has an upward (or downward trend), the algorithm will look for breaks in trend growth. Otherwise, it will look for breaks in the level of the trend. If the growth (or level) is not constant across the entire time series, then a break should be detected</p>
<p>Structural breaks in the cycle are detected using an ARMA(2,1) process, which is the reduced form of the trigonometric specification. Structural breaks in the seasonality is captured by fitting the appropriate Fourier series to the seasonal component determined by the harmonics of the estimated model. If these tests are not stable across the entire time series, then a break will be detected.</p>
<p><code>stsm_detect_breaks</code> will only plot if breaks are detected and <code>plot = TRUE</code>.</p>
</div>
</div>
<div id="example-usage" class="section level1">
<h1>Example Usage</h1>
<p>Below is an example of how to use this package:</p>
<div id="case-1-theoretical-data-example" class="section level2">
<h2>Case 1: Theoretical data example</h2>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(data.table)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">library</span>(ggplot2)</span>
<span id="cb1-3"><a href="#cb1-3"></a><span class="kw">library</span>(gridExtra)</span>
<span id="cb1-4"><a href="#cb1-4"></a><span class="kw">library</span>(autostsm)</span>
<span id="cb1-5"><a href="#cb1-5"></a></span>
<span id="cb1-6"><a href="#cb1-6"></a><span class="kw">set.seed</span>(<span class="dv">1024</span>)</span>
<span id="cb1-7"><a href="#cb1-7"></a></span>
<span id="cb1-8"><a href="#cb1-8"></a><span class="co">#Daily data</span></span>
<span id="cb1-9"><a href="#cb1-9"></a>freq =<span class="st"> </span><span class="fl">365.25</span></span>
<span id="cb1-10"><a href="#cb1-10"></a></span>
<span id="cb1-11"><a href="#cb1-11"></a><span class="co">#Build the trend and drift</span></span>
<span id="cb1-12"><a href="#cb1-12"></a>t =<span class="st"> </span><span class="kw">c</span>()</span>
<span id="cb1-13"><a href="#cb1-13"></a>m =<span class="st"> </span><span class="kw">c</span>()</span>
<span id="cb1-14"><a href="#cb1-14"></a>t[<span class="dv">1</span>] =<span class="st"> </span><span class="dv">100</span></span>
<span id="cb1-15"><a href="#cb1-15"></a>m[<span class="dv">1</span>] =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb1-16"><a href="#cb1-16"></a>sig_e =<span class="st"> </span><span class="fl">0.1</span></span>
<span id="cb1-17"><a href="#cb1-17"></a>sig_t =<span class="st"> </span><span class="dv">1</span></span>
<span id="cb1-18"><a href="#cb1-18"></a>sig_m =<span class="st"> </span><span class="fl">0.1</span></span>
<span id="cb1-19"><a href="#cb1-19"></a>sig_s =<span class="st"> </span><span class="fl">0.01</span></span>
<span id="cb1-20"><a href="#cb1-20"></a><span class="cf">for</span>(i <span class="cf">in</span> <span class="dv">2</span><span class="op">:</span><span class="dv">3000</span>){</span>
<span id="cb1-21"><a href="#cb1-21"></a>  m[i] =<span class="st"> </span><span class="fl">0.05</span> <span class="op">+</span><span class="st"> </span><span class="fl">0.75</span><span class="op">*</span>m[i<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">0</span>, sig_m)</span>
<span id="cb1-22"><a href="#cb1-22"></a>  t[i] =<span class="st"> </span>t[i<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span>m[i<span class="dv">-1</span>] <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="dv">1</span>, <span class="dv">0</span>, sig_t)</span>
<span id="cb1-23"><a href="#cb1-23"></a>}</span>
<span id="cb1-24"><a href="#cb1-24"></a></span>
<span id="cb1-25"><a href="#cb1-25"></a><span class="co">#Build the seasonality including yearly and weekly </span></span>
<span id="cb1-26"><a href="#cb1-26"></a>s1 =<span class="st"> </span><span class="kw">sin</span>(<span class="dv">2</span><span class="op">*</span>pi<span class="op">/</span><span class="fl">365.25</span><span class="op">*</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(t))) <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(t), <span class="dv">0</span>, sig_s)</span>
<span id="cb1-27"><a href="#cb1-27"></a>s1 =<span class="st"> </span>(s1 <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(s1))<span class="op">/</span><span class="kw">diff</span>(<span class="kw">range</span>(s1))<span class="op">*</span>(<span class="fl">1.125</span> <span class="op">-</span><span class="st"> </span><span class="fl">0.865</span>) <span class="op">+</span><span class="st"> </span><span class="fl">0.865</span></span>
<span id="cb1-28"><a href="#cb1-28"></a>s52 =<span class="st"> </span><span class="kw">sin</span>(<span class="dv">2</span><span class="op">*</span>pi<span class="op">/</span>(<span class="fl">365.25</span><span class="op">/</span><span class="dv">52</span>)<span class="op">*</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(t))) <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(t), <span class="dv">0</span>, sig_s)</span>
<span id="cb1-29"><a href="#cb1-29"></a>s52 =<span class="st"> </span>(s52 <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(s52))<span class="op">/</span><span class="kw">diff</span>(<span class="kw">range</span>(s52))<span class="op">*</span>(<span class="fl">1.125</span> <span class="op">-</span><span class="st"> </span><span class="fl">0.865</span>) <span class="op">+</span><span class="st"> </span><span class="fl">0.865</span></span>
<span id="cb1-30"><a href="#cb1-30"></a>s =<span class="st"> </span>s1 <span class="op">+</span><span class="st"> </span>s52</span>
<span id="cb1-31"><a href="#cb1-31"></a>s =<span class="st"> </span>(s <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(s))<span class="op">/</span><span class="kw">diff</span>(<span class="kw">range</span>(s))<span class="op">*</span>(<span class="fl">1.25</span> <span class="op">-</span><span class="st"> </span><span class="fl">0.75</span>) <span class="op">+</span><span class="st"> </span><span class="fl">0.75</span></span>
<span id="cb1-32"><a href="#cb1-32"></a></span>
<span id="cb1-33"><a href="#cb1-33"></a><span class="co">#Build the cyclicality using every 3 years periodicity</span></span>
<span id="cb1-34"><a href="#cb1-34"></a>c =<span class="st"> </span><span class="kw">sin</span>(<span class="dv">2</span><span class="op">*</span>pi<span class="op">*</span><span class="fl">0.33</span><span class="op">/</span><span class="fl">365.25</span><span class="op">*</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(t))) <span class="op">+</span><span class="st"> </span><span class="kw">rnorm</span>(<span class="kw">length</span>(t), <span class="dv">0</span>, sig_s)</span>
<span id="cb1-35"><a href="#cb1-35"></a>c =<span class="st"> </span>(c <span class="op">-</span><span class="st"> </span><span class="kw">min</span>(c))<span class="op">/</span><span class="kw">diff</span>(<span class="kw">range</span>(c))<span class="op">*</span>(<span class="fl">1.25</span> <span class="op">-</span><span class="st"> </span><span class="fl">0.75</span>) <span class="op">+</span><span class="st"> </span><span class="fl">0.75</span></span>
<span id="cb1-36"><a href="#cb1-36"></a></span>
<span id="cb1-37"><a href="#cb1-37"></a><span class="co">#Build the data using a multiplicative model</span></span>
<span id="cb1-38"><a href="#cb1-38"></a>ts =<span class="st"> </span><span class="kw">data.table</span>(<span class="dt">date =</span> <span class="kw">as.Date</span>(<span class="st">&quot;2016-01-01&quot;</span>) <span class="op">+</span><span class="st"> </span><span class="dv">1</span><span class="op">:</span><span class="kw">length</span>(t), </span>
<span id="cb1-39"><a href="#cb1-39"></a>                <span class="dt">y =</span> t<span class="op">*</span>c<span class="op">*</span>s<span class="op">*</span><span class="kw">exp</span>(<span class="kw">rnorm</span>(<span class="kw">length</span>(t), <span class="dv">0</span>, sig_e)), </span>
<span id="cb1-40"><a href="#cb1-40"></a>                <span class="dt">trend =</span> t, <span class="dt">seasonal =</span> s, <span class="dt">seasonal52 =</span> s52, <span class="dt">seasonal1 =</span> s1, <span class="dt">cycle =</span> c)</span>
<span id="cb1-41"><a href="#cb1-41"></a></span>
<span id="cb1-42"><a href="#cb1-42"></a><span class="co">#Create some missing values</span></span>
<span id="cb1-43"><a href="#cb1-43"></a>ts[<span class="kw">sample</span>(<span class="dv">1</span><span class="op">:</span><span class="kw">nrow</span>(ts), <span class="kw">round</span>(<span class="fl">0.05</span><span class="op">*</span><span class="kw">nrow</span>(ts))), <span class="st">&quot;y&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="ot">NA</span>]</span>
<span id="cb1-44"><a href="#cb1-44"></a></span>
<span id="cb1-45"><a href="#cb1-45"></a><span class="co">#View the data</span></span>
<span id="cb1-46"><a href="#cb1-46"></a>g1 =<span class="st"> </span><span class="kw">ggplot</span>(<span class="kw">melt</span>(ts, <span class="dt">id.vars =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">measure.vars =</span> <span class="kw">c</span>(<span class="st">&quot;y&quot;</span>, <span class="st">&quot;trend&quot;</span>))) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-47"><a href="#cb1-47"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Observed vs Trend&quot;</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-48"><a href="#cb1-48"></a><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> date, <span class="dt">y =</span> value, <span class="dt">group =</span> variable, <span class="dt">color =</span> variable)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-49"><a href="#cb1-49"></a><span class="st">  </span><span class="kw">scale_color_viridis_d</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-50"><a href="#cb1-50"></a><span class="st">  </span><span class="kw">theme_minimal</span>() <span class="op">+</span><span class="st"> </span><span class="kw">guides</span>(<span class="dt">color =</span> <span class="kw">guide_legend</span>(<span class="dt">title =</span> <span class="ot">NULL</span>)) <span class="op">+</span></span>
<span id="cb1-51"><a href="#cb1-51"></a><span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>)</span>
<span id="cb1-52"><a href="#cb1-52"></a>g2 =<span class="st"> </span><span class="kw">ggplot</span>(<span class="kw">melt</span>(ts, <span class="dt">id.vars =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">measure.vars =</span> <span class="kw">c</span>(<span class="st">&quot;cycle&quot;</span>))) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-53"><a href="#cb1-53"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Cycle&quot;</span>) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-54"><a href="#cb1-54"></a><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> date, <span class="dt">y =</span> value, <span class="dt">group =</span> variable, <span class="dt">color =</span> variable)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-55"><a href="#cb1-55"></a><span class="st">  </span><span class="kw">scale_color_viridis_d</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-56"><a href="#cb1-56"></a><span class="st">  </span><span class="kw">theme_minimal</span>() <span class="op">+</span><span class="st"> </span><span class="kw">guides</span>(<span class="dt">color =</span> <span class="kw">guide_legend</span>(<span class="dt">title =</span> <span class="ot">NULL</span>)) <span class="op">+</span></span>
<span id="cb1-57"><a href="#cb1-57"></a><span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>)</span>
<span id="cb1-58"><a href="#cb1-58"></a>g3 =<span class="st"> </span><span class="kw">ggplot</span>(<span class="kw">melt</span>(ts, <span class="dt">id.vars =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">measure.vars =</span> <span class="kw">colnames</span>(ts)[<span class="kw">grepl</span>(<span class="st">&quot;seasonal&quot;</span>, <span class="kw">colnames</span>(ts))])) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-59"><a href="#cb1-59"></a><span class="st">  </span><span class="kw">labs</span>(<span class="dt">title =</span> <span class="st">&quot;Seasonal&quot;</span>) <span class="op">+</span></span>
<span id="cb1-60"><a href="#cb1-60"></a><span class="st">  </span><span class="kw">geom_line</span>(<span class="kw">aes</span>(<span class="dt">x =</span> date, <span class="dt">y =</span> value, <span class="dt">group =</span> variable, <span class="dt">color =</span> variable)) <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-61"><a href="#cb1-61"></a><span class="st">  </span><span class="kw">scale_color_viridis_d</span>() <span class="op">+</span><span class="st"> </span></span>
<span id="cb1-62"><a href="#cb1-62"></a><span class="st">  </span><span class="kw">theme_minimal</span>() <span class="op">+</span><span class="st"> </span><span class="kw">guides</span>(<span class="dt">color =</span> <span class="kw">guide_legend</span>(<span class="dt">title =</span> <span class="ot">NULL</span>)) <span class="op">+</span></span>
<span id="cb1-63"><a href="#cb1-63"></a><span class="st">  </span><span class="kw">theme</span>(<span class="dt">legend.position =</span> <span class="st">&quot;bottom&quot;</span>)</span>
<span id="cb1-64"><a href="#cb1-64"></a><span class="kw">grid.arrange</span>(g1, g2, g3, <span class="dt">layout_matrix =</span> <span class="kw">rbind</span>(<span class="kw">c</span>(<span class="dv">1</span>, <span class="dv">1</span>), <span class="kw">c</span>(<span class="dv">2</span>, <span class="dv">3</span>)))</span>
<span id="cb1-65"><a href="#cb1-65"></a></span>
<span id="cb1-66"><a href="#cb1-66"></a><span class="co">#Estimate the model</span></span>
<span id="cb1-67"><a href="#cb1-67"></a>stsm =<span class="st"> </span><span class="kw">stsm_estimate</span>(ts[, <span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="dt">with =</span> <span class="ot">FALSE</span>])</span>
<span id="cb1-68"><a href="#cb1-68"></a></span>
<span id="cb1-69"><a href="#cb1-69"></a><span class="co">#Forecast and plot the results</span></span>
<span id="cb1-70"><a href="#cb1-70"></a>stsm_fc =<span class="st"> </span><span class="kw">stsm_forecast</span>(stsm, <span class="dt">y =</span> ts[, <span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="dt">with =</span> <span class="ot">FALSE</span>], <span class="dt">n.ahead =</span> <span class="kw">floor</span>(stsm<span class="op">$</span>freq)<span class="op">*</span><span class="dv">3</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</span>
<span id="cb1-71"><a href="#cb1-71"></a></span>
<span id="cb1-72"><a href="#cb1-72"></a><span class="co">#Detect Anomalies</span></span>
<span id="cb1-73"><a href="#cb1-73"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb1-74"><a href="#cb1-74"></a>                <span class="kw">stsm_detect_anomalies</span>(stsm, <span class="dt">y =</span> ts[, <span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="dt">with =</span> <span class="ot">FALSE</span>], <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb1-75"><a href="#cb1-75"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb1-76"><a href="#cb1-76"></a></span>
<span id="cb1-77"><a href="#cb1-77"></a><span class="co">#Detect structural breaks</span></span>
<span id="cb1-78"><a href="#cb1-78"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb1-79"><a href="#cb1-79"></a>                <span class="kw">stsm_detect_breaks</span>(stsm, <span class="dt">y =</span> ts[, <span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>), <span class="dt">with =</span> <span class="ot">FALSE</span>], <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb1-80"><a href="#cb1-80"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
</div>
<div id="case-2-real-data-examples" class="section level2">
<h2>Case 2: Real data examples</h2>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="co">##### Unemployment rate examples #####</span></span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">#Not seasonally adjusted</span></span>
<span id="cb2-3"><a href="#cb2-3"></a><span class="kw">data</span>(<span class="st">&quot;UNRATENSA&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;autostsm&quot;</span>) <span class="co">#From FRED</span></span>
<span id="cb2-4"><a href="#cb2-4"></a>UNRATENSA =<span class="st"> </span><span class="kw">data.table</span>(UNRATENSA, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-5"><a href="#cb2-5"></a><span class="kw">colnames</span>(UNRATENSA) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>)</span>
<span id="cb2-6"><a href="#cb2-6"></a>UNRATENSA[, <span class="st">&quot;date&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.Date</span>(date)]</span>
<span id="cb2-7"><a href="#cb2-7"></a>UNRATENSA[, <span class="st">&quot;y&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.numeric</span>(y)]</span>
<span id="cb2-8"><a href="#cb2-8"></a>stsm =<span class="st"> </span><span class="kw">stsm_estimate</span>(UNRATENSA)</span>
<span id="cb2-9"><a href="#cb2-9"></a>stsm_fc =<span class="st"> </span><span class="kw">stsm_forecast</span>(stsm, UNRATENSA, <span class="dt">n.ahead =</span> <span class="kw">floor</span>(stsm<span class="op">$</span>freq)<span class="op">*</span><span class="dv">10</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-10"><a href="#cb2-10"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-11"><a href="#cb2-11"></a>                <span class="kw">stsm_detect_anomalies</span>(stsm, <span class="dt">y =</span> UNRATENSA, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-12"><a href="#cb2-12"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-13"><a href="#cb2-13"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-14"><a href="#cb2-14"></a>                <span class="kw">stsm_detect_breaks</span>(stsm, <span class="dt">y =</span> UNRATENSA, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-15"><a href="#cb2-15"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-16"><a href="#cb2-16"></a></span>
<span id="cb2-17"><a href="#cb2-17"></a><span class="co">#Seasonally adjusted</span></span>
<span id="cb2-18"><a href="#cb2-18"></a><span class="kw">data</span>(<span class="st">&quot;UNRATE&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;autostsm&quot;</span>) <span class="co">#From FRED</span></span>
<span id="cb2-19"><a href="#cb2-19"></a>UNRATE =<span class="st"> </span><span class="kw">data.table</span>(UNRATE, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-20"><a href="#cb2-20"></a><span class="kw">colnames</span>(UNRATE) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>)</span>
<span id="cb2-21"><a href="#cb2-21"></a>UNRATE[, <span class="st">&quot;date&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.Date</span>(date)]</span>
<span id="cb2-22"><a href="#cb2-22"></a>UNRATE[, <span class="st">&quot;y&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.numeric</span>(y)]</span>
<span id="cb2-23"><a href="#cb2-23"></a>stsm =<span class="st"> </span><span class="kw">stsm_estimate</span>(UNRATE)</span>
<span id="cb2-24"><a href="#cb2-24"></a>stsm_fc =<span class="st"> </span><span class="kw">stsm_forecast</span>(stsm, <span class="dt">y =</span> UNRATE, <span class="dt">n.ahead =</span> <span class="kw">floor</span>(stsm<span class="op">$</span>freq)<span class="op">*</span><span class="dv">3</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-25"><a href="#cb2-25"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-26"><a href="#cb2-26"></a>                <span class="kw">stsm_detect_anomalies</span>(stsm, <span class="dt">y =</span> UNRATE, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-27"><a href="#cb2-27"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-28"><a href="#cb2-28"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-29"><a href="#cb2-29"></a>                <span class="kw">stsm_detect_breaks</span>(stsm, <span class="dt">y =</span> UNRATE, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-30"><a href="#cb2-30"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-31"><a href="#cb2-31"></a></span>
<span id="cb2-32"><a href="#cb2-32"></a><span class="co">##### GDP examples #####</span></span>
<span id="cb2-33"><a href="#cb2-33"></a><span class="co">#Not seasonally adjusted</span></span>
<span id="cb2-34"><a href="#cb2-34"></a><span class="kw">data</span>(<span class="st">&quot;NA000334Q&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;autostsm&quot;</span>) <span class="co">#From FRED</span></span>
<span id="cb2-35"><a href="#cb2-35"></a>NA000334Q =<span class="st"> </span><span class="kw">data.table</span>(NA000334Q, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-36"><a href="#cb2-36"></a><span class="kw">colnames</span>(NA000334Q) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>)</span>
<span id="cb2-37"><a href="#cb2-37"></a>NA000334Q[, <span class="st">&quot;date&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.Date</span>(date)]</span>
<span id="cb2-38"><a href="#cb2-38"></a>NA000334Q[, <span class="st">&quot;y&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.numeric</span>(y)]</span>
<span id="cb2-39"><a href="#cb2-39"></a>NA000334Q =<span class="st"> </span>NA000334Q[date <span class="op">&gt;=</span><span class="st"> &quot;1990-01-01&quot;</span>, ]</span>
<span id="cb2-40"><a href="#cb2-40"></a>stsm =<span class="st"> </span><span class="kw">stsm_estimate</span>(NA000334Q)</span>
<span id="cb2-41"><a href="#cb2-41"></a>stsm_fc =<span class="st"> </span><span class="kw">stsm_forecast</span>(stsm, <span class="dt">y =</span> NA000334Q, <span class="dt">n.ahead =</span> <span class="kw">floor</span>(stsm<span class="op">$</span>freq)<span class="op">*</span><span class="dv">3</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-42"><a href="#cb2-42"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-43"><a href="#cb2-43"></a>                <span class="kw">stsm_detect_anomalies</span>(stsm, <span class="dt">y =</span> NA000334Q, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-44"><a href="#cb2-44"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-45"><a href="#cb2-45"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-46"><a href="#cb2-46"></a>                <span class="kw">stsm_detect_breaks</span>(stsm, <span class="dt">y =</span> NA000334Q, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-47"><a href="#cb2-47"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-48"><a href="#cb2-48"></a></span>
<span id="cb2-49"><a href="#cb2-49"></a><span class="co">#Seasonally adjusted</span></span>
<span id="cb2-50"><a href="#cb2-50"></a><span class="kw">data</span>(<span class="st">&quot;GDP&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;autostsm&quot;</span>) <span class="co">#From FRED</span></span>
<span id="cb2-51"><a href="#cb2-51"></a>GDP =<span class="st"> </span><span class="kw">data.table</span>(GDP, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-52"><a href="#cb2-52"></a><span class="kw">colnames</span>(GDP) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>)</span>
<span id="cb2-53"><a href="#cb2-53"></a>GDP[, <span class="st">&quot;date&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.Date</span>(date)]</span>
<span id="cb2-54"><a href="#cb2-54"></a>GDP[, <span class="st">&quot;y&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.numeric</span>(y)]</span>
<span id="cb2-55"><a href="#cb2-55"></a>GDP =<span class="st"> </span>GDP[date <span class="op">&gt;=</span><span class="st"> &quot;1990-01-01&quot;</span>, ]</span>
<span id="cb2-56"><a href="#cb2-56"></a>stsm =<span class="st"> </span><span class="kw">stsm_estimate</span>(GDP)</span>
<span id="cb2-57"><a href="#cb2-57"></a>stsm_fc =<span class="st"> </span><span class="kw">stsm_forecast</span>(stsm, <span class="dt">y =</span> GDP, <span class="dt">n.ahead =</span> <span class="kw">floor</span>(stsm<span class="op">$</span>freq)<span class="op">*</span><span class="dv">3</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-58"><a href="#cb2-58"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-59"><a href="#cb2-59"></a>                <span class="kw">stsm_detect_anomalies</span>(stsm, <span class="dt">y =</span> GDP, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-60"><a href="#cb2-60"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-61"><a href="#cb2-61"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-62"><a href="#cb2-62"></a>                <span class="kw">stsm_detect_breaks</span>(stsm, <span class="dt">y =</span> GDP, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-63"><a href="#cb2-63"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-64"><a href="#cb2-64"></a></span>
<span id="cb2-65"><a href="#cb2-65"></a><span class="co">##### S&amp;P 500 example #####</span></span>
<span id="cb2-66"><a href="#cb2-66"></a><span class="kw">data</span>(<span class="st">&quot;SP500&quot;</span>, <span class="dt">package =</span> <span class="st">&quot;autostsm&quot;</span>) <span class="co">#From FRED</span></span>
<span id="cb2-67"><a href="#cb2-67"></a>SP500 =<span class="st"> </span><span class="kw">data.table</span>(SP500, <span class="dt">keep.rownames =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-68"><a href="#cb2-68"></a><span class="kw">colnames</span>(SP500) =<span class="st"> </span><span class="kw">c</span>(<span class="st">&quot;date&quot;</span>, <span class="st">&quot;y&quot;</span>)</span>
<span id="cb2-69"><a href="#cb2-69"></a>SP500[, <span class="st">&quot;date&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.Date</span>(date)]</span>
<span id="cb2-70"><a href="#cb2-70"></a>SP500[, <span class="st">&quot;y&quot;</span> <span class="op">:</span><span class="er">=</span><span class="st"> </span><span class="kw">as.numeric</span>(y)]</span>
<span id="cb2-71"><a href="#cb2-71"></a>stsm =<span class="st"> </span><span class="kw">stsm_estimate</span>(SP500)</span>
<span id="cb2-72"><a href="#cb2-72"></a>stsm_fc =<span class="st"> </span><span class="kw">stsm_forecast</span>(stsm, <span class="dt">y =</span> SP500, <span class="dt">n.ahead =</span> <span class="kw">floor</span>(stsm<span class="op">$</span>freq)<span class="op">*</span><span class="dv">3</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-73"><a href="#cb2-73"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-74"><a href="#cb2-74"></a>                <span class="kw">stsm_detect_anomalies</span>(stsm, <span class="dt">y =</span> SP500, <span class="dt">plot =</span> <span class="ot">TRUE</span>), </span>
<span id="cb2-75"><a href="#cb2-75"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span>
<span id="cb2-76"><a href="#cb2-76"></a>stsm_fc =<span class="st"> </span><span class="kw">merge</span>(stsm_fc, </span>
<span id="cb2-77"><a href="#cb2-77"></a>                <span class="kw">stsm_detect_breaks</span>(stsm, <span class="dt">y =</span> SP500, <span class="dt">plot =</span> <span class="ot">TRUE</span>),</span>
<span id="cb2-78"><a href="#cb2-78"></a>                <span class="dt">by =</span> <span class="st">&quot;date&quot;</span>, <span class="dt">all =</span> <span class="ot">TRUE</span>)</span></code></pre></div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
